<!DOCTYPE html>
<html lang="he" dir="rtl"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>שפות רגולריות - משפט קלייני | לא מדויק</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="שפות רגולריות - משפט קלייני" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="את הדיון שלי על שפות רגולריות התחלתי בהצגה של מושג האוטומט הסופי הדטרמיניסטי. האוטומט הזה היה מין מכונת חישוב תאורטית שמבצעת פעולה של זיהוי מתי מילה שייכת או לא שייכת לשפה כלשהי. הגדרתי את אוסף השפות הרגולריות בתור השפות שמתקבלות על ידי אוטומט כזה. אחר כך התחלתי להתעסק בתכונות סגור של שפות רגולריות - פעולות שאפשר להפעיל על שפות רגולריות קיימות ולקבל כתוצרים שפות רגולריות חדשות - כשחלק מהיעד שלי היה למצוא קבוצה קטנה יחסית של פעולות סגור ו”שפות בסיס” שמהן ניתן ליצור את כל השפות הרגולריות. את מה שהגעתי אליו בסופו של דבר אפשר לנסח כך: שפות הבסיס הן כל השפות שיש בהן לכל היותר מילה אחת מאורך לכל היותר 1; ופעולות הסגור הן איחוד, שרשור וסגור-קלייני. הטענה הזו נקראת לפעמים “משפט קלייני” וכך אקרא לה כאן (אין קונצנזוס בשפות על מה בדיוק נקרא “משפט קלייני” בהקשר של שפות רגולריות; יש כמה ניסוחים שונים ואני לא אכנס לדיון הזה כי הוא משעמם)." />
<meta property="og:description" content="את הדיון שלי על שפות רגולריות התחלתי בהצגה של מושג האוטומט הסופי הדטרמיניסטי. האוטומט הזה היה מין מכונת חישוב תאורטית שמבצעת פעולה של זיהוי מתי מילה שייכת או לא שייכת לשפה כלשהי. הגדרתי את אוסף השפות הרגולריות בתור השפות שמתקבלות על ידי אוטומט כזה. אחר כך התחלתי להתעסק בתכונות סגור של שפות רגולריות - פעולות שאפשר להפעיל על שפות רגולריות קיימות ולקבל כתוצרים שפות רגולריות חדשות - כשחלק מהיעד שלי היה למצוא קבוצה קטנה יחסית של פעולות סגור ו”שפות בסיס” שמהן ניתן ליצור את כל השפות הרגולריות. את מה שהגעתי אליו בסופו של דבר אפשר לנסח כך: שפות הבסיס הן כל השפות שיש בהן לכל היותר מילה אחת מאורך לכל היותר 1; ופעולות הסגור הן איחוד, שרשור וסגור-קלייני. הטענה הזו נקראת לפעמים “משפט קלייני” וכך אקרא לה כאן (אין קונצנזוס בשפות על מה בדיוק נקרא “משפט קלייני” בהקשר של שפות רגולריות; יש כמה ניסוחים שונים ואני לא אכנס לדיון הזה כי הוא משעמם)." />
<link rel="canonical" href="http://localhost:4000/blog/2014/12/24/regular_languages_kleene_theorem" />
<meta property="og:url" content="http://localhost:4000/blog/2014/12/24/regular_languages_kleene_theorem" />
<meta property="og:site_name" content="לא מדויק" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2014-12-24T16:05:16+02:00" />
<script type="application/ld+json">
{"headline":"שפות רגולריות - משפט קלייני","dateModified":"2014-12-24T16:05:16+02:00","datePublished":"2014-12-24T16:05:16+02:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/2014/12/24/regular_languages_kleene_theorem"},"url":"http://localhost:4000/blog/2014/12/24/regular_languages_kleene_theorem","description":"את הדיון שלי על שפות רגולריות התחלתי בהצגה של מושג האוטומט הסופי הדטרמיניסטי. האוטומט הזה היה מין מכונת חישוב תאורטית שמבצעת פעולה של זיהוי מתי מילה שייכת או לא שייכת לשפה כלשהי. הגדרתי את אוסף השפות הרגולריות בתור השפות שמתקבלות על ידי אוטומט כזה. אחר כך התחלתי להתעסק בתכונות סגור של שפות רגולריות - פעולות שאפשר להפעיל על שפות רגולריות קיימות ולקבל כתוצרים שפות רגולריות חדשות - כשחלק מהיעד שלי היה למצוא קבוצה קטנה יחסית של פעולות סגור ו”שפות בסיס” שמהן ניתן ליצור את כל השפות הרגולריות. את מה שהגעתי אליו בסופו של דבר אפשר לנסח כך: שפות הבסיס הן כל השפות שיש בהן לכל היותר מילה אחת מאורך לכל היותר 1; ופעולות הסגור הן איחוד, שרשור וסגור-קלייני. הטענה הזו נקראת לפעמים “משפט קלייני” וכך אקרא לה כאן (אין קונצנזוס בשפות על מה בדיוק נקרא “משפט קלייני” בהקשר של שפות רגולריות; יש כמה ניסוחים שונים ואני לא אכנס לדיון הזה כי הוא משעמם).","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link href="/blog/assets/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  <link rel="stylesheet" href="/blog/assets/css/main.css">
  <link rel="shortcut icon" href="/blog/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/blog/favicon.ico" type="image/x-icon"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/blog/feed.xml" title="לא מדויק" /><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$latex','$'] ],
        processEscapes: true
      },
       TeX: {extensions: ["AMSmath.js","AMSsymbols.js"]}
    });
  </script>
  <!-- "https://www.gadial.net/wp-includes/js/xypic.js" -->

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
  
</head>
<body><header>
  <nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark">
    <a class="navbar-brand" href="/blog/main">לא מדויק</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarCollapse">
      <ul class="navbar-nav mr-auto">
        
            
            <li class="nav-item">
                <a class="nav-link" href="/blog/main">דף הבית</a>
            </li>
            
        
            
            <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="dropdown1" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">נושאים</a>
            <div class="dropdown-menu" aria-labelledby="dropdown1">
            
            <a class="dropdown-item text-right" href="/blog/analysis">אנליזה</a>
            
            <a class="dropdown-item text-right" href="/blog/algebra">אלגברה</a>
            
           </div>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/blog/categories">קטגוריות</a>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/blog/about/">אודות</a>
            </li>
            
        
      </ul>
      <form class="form-inline mt-2 mt-md-0" action="post_list.html" method="get">
        <input class="form-control mr-sm-2" type="text" placeholder="חיפוש" aria-label="חיפוש" name="s">
        <button class="btn btn-outline-success my-2 my-sm-0" type="submit">חיפוש</button>
      </form>
    </div>
  </nav>
</header><main class="page-content" aria-label="Content" role="main">
      <div class="wrapper text-right">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">שפות רגולריות - משפט קלייני</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2014-12-24T16:05:16+02:00" itemprop="datePublished">Dec 24, 2014
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>את הדיון שלי על שפות רגולריות התחלתי בהצגה של מושג האוטומט הסופי הדטרמיניסטי. האוטומט הזה היה מין מכונת חישוב תאורטית שמבצעת פעולה של <strong>זיהוי</strong> מתי מילה שייכת או לא שייכת לשפה כלשהי. הגדרתי את אוסף <strong>השפות הרגולריות</strong> בתור השפות שמתקבלות על ידי אוטומט כזה. אחר כך התחלתי להתעסק בתכונות סגור של שפות רגולריות - פעולות שאפשר להפעיל על שפות רגולריות קיימות ולקבל כתוצרים שפות רגולריות חדשות - כשחלק מהיעד שלי היה למצוא קבוצה קטנה יחסית של פעולות סגור ו”שפות בסיס” שמהן ניתן ליצור את כל השפות הרגולריות. את מה שהגעתי אליו בסופו של דבר אפשר לנסח כך: שפות הבסיס הן כל השפות שיש בהן לכל היותר מילה אחת מאורך לכל היותר 1; ופעולות הסגור הן איחוד, שרשור וסגור-קלייני. הטענה הזו נקראת לפעמים “משפט קלייני” וכך אקרא לה כאן (אין קונצנזוס בשפות על מה בדיוק נקרא “משפט קלייני” בהקשר של שפות רגולריות; יש כמה ניסוחים שונים ואני לא אכנס לדיון הזה כי הוא משעמם).</p>

<p>בפוסט הזה אני רוצה להוכיח את הטענה הזו בצורה פורמלית יחסית. בואו נתחיל.</p>

<p>אם כבר פורמליזם, צריך לזכור שברקע של הדיון שלנו תמיד יש קבוצה סופית <span>$latex \Sigma$</span> שנקראת <strong>אלפבית</strong> - מתוכה נלקחות האותיות שמהן נבנות מילים. כשאני מדבר על שפות רגולריות, אני בעצם אומר “השפות הרגולריות שמורכבות ממילים שבנויות מתוך אותיות <span>$latex \Sigma$</span>”. כל מה שאעשה בהמשך לא ממש תלוי ב-<span>$latex \Sigma$</span> (אולי אניח באופן מובלע שזו לא קבוצה ריקה אחרת אין בכלל מילים חוץ מהמילה הריקה) במובן זה שלכל <span>$latex \Sigma$</span> סופית ההוכחות עובדות באותה מידה בדיוק.</p>

<p>קבוצת שפות הבסיס שלי, אם כן, היא הקבוצה הבאה: <span>$latex \left\{ \emptyset,\left\{ \varepsilon\right\} \right\} \cup\left\{ \left\{ \sigma\right\} \ |\ \sigma\in\Sigma\right\} $</span>. דהיינו, השפה הריקה, השפה שהאיבר היחיד שלה הוא המילה הריקה, והשפה שהאיבר היחיד שלה הוא המילה מאורך 1 <span>$latex \sigma$</span>, לכל אות <span>$latex \sigma\in\Sigma$</span>.</p>

<p>מבין פעולות הסגור, איחוד שפות זו פשוט פעולת האיחוד הרגילה של קבוצות. שרשור של שפות הוגדר להיות <span>$latex L_{1}\cdot L_{2}\triangleq\left\{ w_{1}w_{2}\ |\ w_{1}\in L_{1},w_{2}\in L_{2}\right\} $</span> (כששרשור של מילים מוגדר בצורה הרגילה - המילה שמתקבלת מ”הדבקת” שתי המילים על פי הסדר שלהן). סגור-קלייני היה הפעולה המסובכת ביותר והפחות טבעית מבין הפעולות: <span>$latex L^{*}\triangleq\bigcup_{n=0}^{\infty}L^{n}$</span>, כאשר חזקה של שפות מוגדרת באופן הטבעי: <span>$latex L^{0}\triangleq\left\{ \varepsilon\right\} $</span> ו-<span>$latex L^{n+1}\triangleq L^{n}\cdot L$</span>. כזכור, הגדרתי את סגור-קליניי מלכתחילה כי הייתה לי “אינטואיציה” שזו הפעולה שאזדקק לה כדי להוכיח את משפט קלייני. מה שיהיה נחמד בהוכחה (בין היתר) הוא שנבין <strong>בדיוק</strong> למה צריך דווקא את הפעולה הזו.</p>

<p>המשפט אומר שקבוצת השפות הרגולריות היא הקבוצה שנוצרת אינדוקטיבית מהבסיס ופעולות היצירה הללו. לא חייבים להבין מה זו קבוצה נוצרת אינדוקטיבית, אבל זה לא יזיק אז אקדיש לכך כמה פסקאות ואפשר לדלג אם רוצים. הרעיון הוא שזו <strong>הקבוצה הקטנה ביותר</strong> שמכילה את הבסיס וסגורה לפעולות היצירה. באופן כללי, אם יש לי “עולם” <span>$latex X$</span>, קבוצת <strong>בסיס</strong> <span>$latex B\subseteq X$</span> וקבוצה <span>$latex F$</span> של <strong>פעולות יצירה </strong>שהן פונקציות מהצורה <span>$latex f:X^{n}\to X$</span> (כלומר, פונקציות שמקבלות <span>$latex n$</span> קלטים, כאשר <span>$latex n$</span> יכול להיות מספר טבעי חיובי כלשהו), אז אסמן ב-<span>$latex X_{B,F}$</span> את הקבוצה הקטנה ביותר כך ש-<span>$latex B\subseteq X_{B,F}$</span> ולכל <span>$latex f\in F$</span> מתקיים ש-<span>$latex f\left(X_{B,F}\right)\subseteq X_{B,F}$</span> (הסימון “<span>$latex f\left(D\right)$</span>” לקבוצה <span>$latex D$</span> כלשהו פירושו כל הפלטים שמקבלים כאשר מציבים ב-<span>$latex f$</span> את כל הקומבינציות האפשריות של איברים ב-<span>$latex D$</span>; הסיבה שאני בכלל טורח לומר זאת במפורש היא שאם <span>$latex f$</span> היא פונקציה שמקבלת כמה קלטים, יכול להיראות לחלקכם מוזר שפתאום אני מכניס לה את ה”קלט” <span>$latex D$</span>. זה לא באמת קלט; זה סימון של התמונה של <span>$latex f$</span>).</p>

<p>עכשיו, תשאלו, למה הקבוצה הזו בכלל קיימת? ובכן, הנה טענה חביבה: <span>$latex X_{B,F}=\bigcap\left\{ D\subseteq X\ |\ B\subseteq D\wedge\forall f\in F:f\left(D\right)\subseteq D\right\} $</span>. במילים: <span>$latex X_{B,F}$</span> מתקבלת מחיתוך כל הקבוצות שמכילות את <span>$latex B$</span> וסגורות תחת <span>$latex F$</span>. זו דרך סטנדרטית במתמטיקה להגדיר אובייקטים “הכי קטנים” שכאלו באמצעות חיתוך מסוג זה. חשוב לשים לב לכך שהחיתוך לא נלקח מעל קבוצה ריקה של אובייקטים; <span>$latex X$</span> עצמו תמיד נכלל כאיבר בחיתוך. לכן החיתוך מוגדר היטב, ולא קשה להוכיח שהוא אכן שווה ל-<span>$latex X_{B,F}$</span>.</p>

<p>מה שנחמד ב-<span>$latex X_{B,F}$</span> הוא שקל להוכיח עליה טענות באינדוקציה: מוכיחים שמשהו מתקיים עבור <span>$latex B$</span> ומשתמר עבור כל <span>$latex f\in F$</span> ומקבלים שאותו משהו מתקיים לכל <span>$latex X_{B,F}$</span>. בעזרת אינדוקציית מבנה שכזו אפשר להוכיח, למשל, שאיבר כלשהו שייך ל-<span>$latex X_{B,F}$</span> אם ורק אם קיימת לו <strong>סדרת יצירה</strong> - סדרה סופית שכל איבר בה הוא או איבר של <span>$latex B$</span> או מתקבל מאיברים קודמים בסדרה על ידי הפעלת <span>$latex f$</span>, והאיבר האחרון בה הוא האיבר שהסדרה “יוצרת”. אולי לחלקכם זה מזכיר את האופן שבו מתוארות הוכחות במתמטיקה - סדרה של טענות כך שכל טענה היא אקסיומה או הנחה או נובעת מקודמותיה על ידי כלל היסק. זה כמובן לא מקרי - אפשר להגדיר את “קבוצת המשפטים היכיחים” (מאקסיומות/הנחות נתונות ועם כללי היסק נתונים) בדיוק בתור קבוצה אינדוקטיבית שכזו.</p>

<p>חזרה לענייננו - המסקנה שלנו מכל הדיון שלמעלה היא שכדי להוכיח את משפט קלייני, צריך לעשות שני דברים. ראשית, להוכיח שקבוצת השפות הרגולריות אכן כוללת את הבסיס וסגורה ביחס לפעולות הסגור. את זה עשיתי בפוסטים הקודמים. הדבר השני שצריך להראות הוא שכל שפה רגולרית אכן ניתנת ליצירה מתוך הבסיס בעזרת פעולות הסגור, במספר סופי של פעולות (זו “סדרת היצירה” המדוברת). זה מה שנעשה בפוסט הזה.</p>

<p>אם כן, הבה וניקח אוטומט סופי דטרמיניסטי כלשהו, <span>$latex A=\left(\Sigma,Q,q_{1},\delta,F\right)$</span>. אני מסמן את מצבי האוטומט בתור <span>$latex Q=\left\{ q_{1},q_{2},\dots,q_{n}\right\} $</span>. שימו לב שאני בוחר הפעם לסמן את המצב ההתחלתי של האוטומט ב-<span>$latex q_{1}$</span> במקום ב-<span>$latex q_{0}$</span> כרגיל; הסיבה לכך תתברר בהמשך אבל היא לא משהו קריטי - זה פשוט יפשט קצת סימון אחר שאציג עוד מעט.</p>

<p>עכשיו אפשר סוף סוף לדבר על השאלה המרכזית שלנו - איך לכל הרוחות פעולות היצירה שלנו קשורות בכלל למה שאוטומט סופי דטרמיניסטי עושה? אוטומט רץ על מילים וחושב מחשבות עמוקות ובסוף פולט תשובה. פעולות יצירה… ובכן, הן בונות שפות. מה הקשר? איך בכלל ניגשים לזה? זו שאלה טובה מאוד ולא פשוטה בכלל, והעובדה שיש לה תשובה חדה ואלגנטית שפותרת את הכל היא אחת הסיבות שבגללן התוצאה הזו יפה כל כך.</p>

<p>כדי להגיע לתשובה הזו, בואו ננסה לחשוב שניה באופן הבא: שפות הן קבוצות של מילים. מה זו מילה עבור אוטומט? קל להגיד “מה שהוא רץ עליה ומכריע אם היא בשפה או לא”, אבל בעצם מילה היא יותר מזה - מילה היא אובייקט ש<strong>פועל</strong> על האוטומט - גורם לו לעבור ממצב א’ אל מצב ב’. מכיוון שאנחנו עוסקים כאן באוטומט סופי דטרמיניסטי, שאין לו זכרון בשום מקום מלבד המצבים שלו, כדי להבין באופן מלא מה האוטומט עושה, צריך רק להבין את אותן פעולות - מה גורם לאוטומט לעבור ממצב א’ למצב ב’.</p>

<p>אז אני יכול לנסות ולהגדיר שפות באופן הבא: לכל זוג מצבים <span>$latex q,p\in Q$</span> נגדיר <span>$latex L_{q,p}=\left\{ w\in\Sigma^{*}\ |\ \hat{\delta}\left(q,w\right)=p\right\} $</span> - שפת כל המילים שמעבירות את האוטומט מ-<span>$latex q$</span> אל <span>$latex p$</span>. אם נצליח לבנות את השפות הללו, בבירור סיימנו, כי <span>$latex L\left(A\right)=\bigcup_{p\in F}L_{q_{0},p}$</span> (שפת האוטומט היא אוסף כל המילים שמעבירות את האוטומט מהמצב ההתחלתי <span>$latex q_{0}$</span> אל מצב מקבל כלשהו <span>$latex p\in F$</span>). אז מה הבעיה? שאין לי מושג איך לבנות את <span>$latex L_{q,p}$</span>, מן הסתם. זו עדיין שפה מסובכת, אפילו אם היא אולי פחות מסובכת מ”כל המילים שהאוטומט מקבל”.</p>

<p>אם השתמשתי בטריק של “לעבור מהשפה הקשה <span>$latex L\left(A\right)$</span> לאיחוד של שפות יותר פשוטות מהצורה <span>$latex L_{q,p}$</span>” אולי אפשר לעשות את התעלול הזה שוב? אני אוטומטית חושב על כך שאפשר לפרק את <span>$latex L_{q,p}$</span> על פי <strong>אורך</strong> המילים. כלומר, אסמן <span>$latex L_{q,p}^{k}\triangleq\left\{ w\in L_{q,p}\ |\ \left|w\right|=k\right\} $</span> ואז <span>$latex L_{q,p}=\bigcup_{k=0}^{\infty}L_{q,p}^{k}$</span>. על פניו זה רעיון די טוב, כי אני יכול לתאר את <span>$latex L_{q,p}^{k}$</span> באופן <strong>אינדוקטיבי</strong> על פי פירוק לפי הצעד האחרון: <span>$latex L_{q,p}^{k}=\bigcup_{i=1}^{n}\left\{ w\sigma\ |\ w\in L_{q,q_{i}}^{k-1}\wedge\delta\left(q_{i},\sigma\right)=p\right\} $</span>. במילים: <span>$latex L_{q,p}^{k}$</span> כוללת את כל המילים מהצורה <span>$latex w\sigma$</span> כך ש-<span>$latex w$</span> היא מאורך <span>$latex k-1$</span> ומעבירה את האוטומט מ-<span>$latex q$</span> אל מצב <span>$latex q_{i}$</span> כלשהו, ואילו <span>$latex \sigma$</span> מעבירה אותנו מ-<span>$latex q_{i}$</span> אל <span>$latex p$</span>.</p>

<p>זה לא עובד. זה רעיון נחמד, אבל זה לא עובד. לא בגלל שזה לא נכון, אלא בגלל המשוואה הזו: <span>$latex L_{q,p}=\bigcup_{k=0}^{\infty}L_{q,p}^{k}$</span>. כתבתי בכוונה את המשוואה הזו בצורה מטעה. אם נלך על פי ההגדרות היבשות שנתתי קודם, הרי ש-<span>$latex \bigcup_{k=0}^{\infty}L_{q,p}^{k}$</span> היא בעצם <span>$latex L_{p,q}^{*}$</span> וזה כמובן לא נכון, כי ה-<span>$latex k$</span> שמופיע ב-<span>$latex L_{q,p}^{k}$</span> הוא לא חזקה של שפה - הוא בסך הכל חלק מהסימון שאני משתמש בו. אני בכוונה מנסה להטעות אתכם ככה כדי להכריח אתכם לחשוב קצת ולהבין מה השתבש כאן. זה חשוב.</p>

<p>אם כן, המשוואה <span>$latex L_{q,p}=\bigcup_{k=0}^{\infty}L_{q,p}^{k}$</span> היא אמנם נכונה לגמרי, אבל היא מציגה את <span>$latex L_{q,p}$</span> בתור איחוד אינסופי של שפות - ואיחוד אינסופי שכזה הוא לא בהכרח רגולרי גם אם השפות המעורבות רגולריות. לכן כל הגישה שלנו של לפרק את <span>$latex L_{q,p}$</span> על פי אורך המילה נידונה לכישלון - אורכי המילים הם לא חסומים ולכן בהכרח נקבל איחודים אינסופיים בעייתיים.</p>

<p>אז חזרה אל שולחן השרטוט ואל השאלה הבסיסית שלנו - מה <strong>כן</strong> חסום כאן? והתשובה ברורה - מספר המצבים של האוטומט <span>$latex A$</span>, שהוא בדיוק <span>$latex n$</span>. אבל איך אפשר להשתמש בזה כדי לפשט את <span>$latex L_{q,p}$</span>?</p>

<p>אנחנו רוצים איכשהו <strong>להגביל</strong> את המילים ב-<span>$latex L_{q,p}$</span> ולקחת רק חלק מהן. קודם הגבלנו על פי אורך. עכשיו אני רוצה להגביל איכשהו על פי מצבי האוטומט. אני יודע שהמילים ב-<span>$latex L_{q,p}$</span> מעבירות את האוטומט מ-<span>$latex q$</span> אל <span>$latex p$</span>, אז איך שאר מצבי האוטומט יכולים להיכנס לתמונה? מתי הם רלוונטיים? ובכן, בדיוק כשאנחנו מסתכלים על <strong>המסלול</strong> שמעביר אותנו מ-<span>$latex q$</span> אל <span>$latex p$</span>. אם אני רוצה <strong>להגביל</strong>, מה אני יכול לעשות? לי נראה ברור (כי ברור שהכל נראה לי ברור בדיעבד, כשאני כבר מכיר את ההוכחה…) שהדרך הנכונה להגביל היא <strong>לאסור</strong> על מעבר במצבים מסויימים. אפשר להמשיך עם המשחק הזה עוד קצת, אבל אני מאמין שמכאן ועד להגדרה הנכונה זה בעיקר ניסוי וטעיה וגישוש, אז הנה אתן את ההגדרה המרכזית כאן, שפותרת את הכל:</p>

<p>אני אגדיר את <span>$latex L_{q,p}^{k}$</span> (כאשר שוב, ה-<span>$latex k$</span> הזה <strong>הוא לא</strong> חזקה, הוא סתם סימון) להיות שפת כל המילים שמעבירות את האוטומט מ-<span>$latex q$</span> אל <span>$latex p$</span>, באופן כזה שהמסלול מ-<span>$latex q$</span> אל <span>$latex p$</span> לא עובר באף מצב שהאינדקס שלו גדול מ-<span>$latex k$</span>. דגש על המילה <strong>עובר</strong>: האוטומט יכול <strong>להתחיל</strong> או <strong>לסיים</strong> את המסלול במצב שהאינדקס שלו גדול מ-<span>$latex k$</span>. כלומר, מותר ל-<span>$latex q$</span> או <span>$latex p$</span> עצמם להיות בעלי אינדקס גדול מ-<span>$latex k$</span>, כל עוד הם מופיעים רק בהתחלה ובסוף ולא בתוך המסלול בעצמם.</p>

<p>ומכיוון שאי אפשר רק עם הגדרה מילולית, הנה הגדרה פורמלית:</p>

<p><span>$latex L_{q,p}^{k}\triangleq\left\{ w\in\Sigma^{*}\ |\ \hat{\delta}\left(q,w\right)=p\wedge\forall u\ne\varepsilon,w:w=uv\wedge\hat{\delta}\left(q,u\right)=q_{i}\Rightarrow i\le k\right\} $</span></p>

<p>ההגדרה הזו אומרת - כל המילים <span>$latex w\in\Sigma^{*}$</span> כך שקודם כל, <span>$latex w$</span> מעבירה את האוטומט מ-<span>$latex q$</span> אל <span>$latex p$</span>; וחוץ מזה, לכל פירוק <span>$latex w=uv$</span> לא טריוויאלי (כלומר, ש-<span>$latex u$</span> היא לא ריקה או לא כל <span>$latex w$</span>), המצב שאליו מגיעים מ-<span>$latex q$</span> אחרי קריאת <span>$latex u$</span> הוא בעל אינדקס קטן או שווה ל-<span>$latex k$</span>.</p>

<p>זהו זה. ההגדרה הזו פותרת את הכל. עד כדי כך שאני ממליץ לכם לא לנסות להמשיך לקרוא את ההוכחה אלא לנסות להמשיך להוכיח בעצמכם לפי שתיגשו לקרוא את המשך ההוכחה שלי.</p>

<p>המשך ההוכחה הוא זה: אני הולך להוכיח באופן אינדוקטיבי שכל השפות <span>$latex L_{q,p}^{k}$</span> הן נוצרות אינדוקטיבית מקבוצות הבסיס באמצעות פעולות הסגור (עבור <span>$latex p,q\in Q$</span> כלשהם ו-<span>$latex 0\le k\le n$</span>). זה יסיים את ההוכחה בגלל שברור לחלוטין ש-<span>$latex L_{q,p}^{n}=L_{q,p}$</span> (כי אם המגבלה שלנו על המילים ב-<span>$latex L_{q,p}$</span> היא “בקריאה שלכן אסור לעבור במצב עם אינדקס גדול מ-<span>$latex n$</span>” והאינדקס הגדול ביותר של מצב באוטומט הוא <span>$latex n$</span>, אין מגבלה). האינדוקציה תהיה על <span>$latex k$</span>.</p>

<p>נתחיל מ-<span>$latex k=0$</span>. במקרה הזה, <span>$latex L_{q,p}^{k}$</span> היא שפה מוגבלת במיוחד. מכיוון שבחרתי שהאינדקס של מצב באוטומט שלי יתחיל מ-1 (ו<strong>זו</strong> הסיבה שבגללה בחרתי את הבחירה הזו, אחרת הייתי צריך להתחיל מ-<span>$latex k=-1$</span>) הרי ש-<span>$latex L_{q,p}^{0}$</span> היא שפת כל המילים <span>$latex w$</span> שקריאתן מעבירה את <span>$latex q$</span> ל-<span>$latex p$</span> <strong>בלי מצבי ביניים בכלל</strong>. כלומר, מעבירה בלכל היותר צעד אחד. זה מראה מייד ש-<span>$latex L_{q,p}^{0}$</span> היא איחוד סופי של שפות בסיס שלנו, או שהיא <span>$latex \emptyset$</span> שגם היא שפת בסיס. אבל אני ארחיב קצת עבור מי שלא רואה את זה.</p>

<p>ראשית, שימו לב לכך ש-<span>$latex q=p$</span> אם ורק אם <span>$latex \varepsilon\in L_{q,p}^{0}$</span> (כי <span>$latex \hat{\delta}\left(q,\varepsilon\right)=q$</span> - כך זה הוגדר). כמו כן, לכל <span>$latex \sigma\in\Sigma$</span> מתקיים ש-<span>$latex \delta\left(q,\sigma\right)=p$</span> אם ורק אם <span>$latex \sigma\in L_{q,p}^{0}$</span>. זה אומר שאפשר לכתוב את השפה שלנו בקיצור בתור:</p>

<p><span>$latex L_{q,p}^{0}=\left\{ \tau\in\Sigma\cup\left\{ \varepsilon\right\} \ |\ \hat{\delta}\left(q,\tau\right)=p\right\} =\bigcup_{\hat{\delta}\left(q,\tau\right)=p}\left\{ \tau\right\} $</span></p>

<p>מכיוון ש-<span>$latex \tau\in\Sigma\cup\left\{ \varepsilon\right\} $</span>, כל שפה מהצורה <span>$latex \left\{ \tau\right\} $</span> היא אחת משפות הבסיס שלנו. ואם יוצא ש-<span>$latex L_{q,p}^{0}=\emptyset$</span> גם זה בסדר כי גם <span>$latex \emptyset$</span> היא אחת משפות הבסיס שלנו. וזה כמובן לא מקרי - זו הסיבה שבגללה בחרנו את שפות הבסיס הללו.</p>

<p>סיימנו עם בסיס האינדוקציה שלנו. כעת לאקשן האמיתי: נניח שכל השפות <span>$latex L_{q,p}^{k-1}$</span> עבור <span>$latex q,p\in Q$</span> כלשהם הן אינדוקטיביות (נוצרו מקבוצות הבסיס על ידי פעולות הסגור) ונוכיח ש-<span>$latex L_{q,p}^{k}$</span> הן כאלו. כלומר, ניקח <span>$latex q,p\in Q$</span> כלשהם ונראה איך אפשר “לבנות” את <span>$latex L_{q,p}^{k}$</span> מתוך שפות עם <span>$latex k-1$</span> למעלה, בעזרת פעולות הסגור.</p>

<p>נתחיל בשאלה המתבקשת - מה ההבדל בין <span>$latex L_{q,p}^{k}$</span> ובין <span>$latex L_{q,p}^{k-1}$</span>? ברור ש-<span>$latex L_{q,p}^{k-1}\subseteq L_{q,p}^{k}$</span>; רק צריך להבין מי המילים ב-<span>$latex L_{q,p}^{k}$</span> שלא נמצאות ב-<span>$latex L_{q,p}^{k-1}$</span>. על פי הגדרה, אלו כל המילים שלא עוברות באף מצב ביניים עם אינדקס גדול מ-<span>$latex k$</span>, אבל <strong>כן </strong>עוברות במצב ביניים עם אינדקס גדול מ-<span>$latex k-1$</span> - כלומר, אלו בדיוק המילים שעוברות במצב <span>$latex q_{k}$</span> לפחות פעם אחת.</p>

<p>עכשיו, בואו נניח ש-<span>$latex w\in L_{q,p}^{k}$</span> היא מילה שמעבירה את <span>$latex q$</span> ל-<span>$latex p$</span> ועוברת ב-<span>$latex q_{k}$</span> <strong>בדיוק</strong> פעם אחת (ובשאר הזמן היא עוברת רק במצבים עם אינדקס קטן יותר). זה אומר שאפשר לפרק אותה כך - <span>$latex w=uv$</span> כך ש-<span>$latex u$</span> מעבירה את <span>$latex q$</span> אל <span>$latex q_{k}$</span> ואילו <span>$latex v$</span> מעבירה את <span>$latex q_{k}$</span> אל <span>$latex p$</span>, ובשני המקרים הללו לא עוברים במצב ביניים עם אינדקס גדול מ-<span>$latex k-1$</span> - כי בכל <span>$latex w$</span> לא עוברים במצב ביניים עם אינדקס גדול מ-<span>$latex k$</span>, וכי <strong>בתוך</strong> הריצה של <span>$latex u$</span> ושל <span>$latex v$</span> לא מופיע <span>$latex q_{k}$</span>, אלא רק ב<strong>קצוות</strong> של הריצה הזו (בסיום הריצה על <span>$latex u$</span> ובתחילת הריצה על <span>$latex v$</span>. מכאן ש-<span>$latex v\in L_{q,q_{k}}^{k-1}$</span> ואילו <span>$latex u\in L_{q_{k},p}^{k-1}$</span>.</p>

<p>המקרה הזה היה פשוט יחסית. בואו נעבור לרמת הסיבוך הבאה: נניח ש-<span>$latex w\in L_{q,p}^{k}$</span> היא מילה שמעבירה את <span>$latex q$</span> ל-<span>$latex p$</span> ועוברת ב-<span>$latex q_{k}$</span> בדיוק <strong>פעמיים</strong>. עכשיו אפשר לפרק את <span>$latex w$</span> כך: <span>$latex w=uzv$</span> כך ש-<span>$latex v\in L_{q,q_{k}}^{k-1}$</span> ואילו <span>$latex u\in L_{q_{k},p}^{k-1}$</span>. ומה עם <span>$latex z$</span>? ובכן, הוא מייצג את החלק בריצה שבין ההגעה הראשונה ל-<span>$latex q_{k}$</span> ובין ההגעה השניה ל-<span>$latex q_{k}$</span>, כלומר <span>$latex z\in L_{q_{k},q_{k}}^{k-1}$</span>.</p>

<p>ועכשיו בואו נניח ש-<span>$latex w\in L_{q,p}^{k}$</span> היא מילה שמעבירה את <span>$latex q$</span> ל-<span>$latex p$</span> ועוברת ב-<span>$latex q_{k}$</span> בדיוק <strong>שלוש פעמיים</strong>. עכשיו אפשר לפרק את <span>$latex w$</span> בתור <span>$latex w=uz_{1}z_{2}v$</span> כאשר <span>$latex z_{1},z_{2}\in L_{q_{k},q_{k}}^{k-1}$</span>.כבר הבנתם לאן אני חותר? אם לא, בואו נדבר על מילה שעוברת ב-<span>$latex q_{k}$</span> בדיוק <strong>ארבע</strong> פעמים - עכשיו נפרק אותה בתור <span>$latex uz_{1}z_{2}z_{3}v$</span> כאשר <span>$latex z_{1},z_{2},z_{3}\in L_{q_{k},q_{k}}^{k-1}$</span>. ובאופן כללי? באופן כללי זה מסורבל מדי לכתוב את כל ה-<span>$latex z$</span>-ים הללו, ולכן אפשר להשתמש ב<strong>חזקה של שפה</strong>: אם <span>$latex w\in L_{q,p}^{k}$</span> היא מילה שמעבירה את <span>$latex q$</span> ל-<span>$latex p$</span> ועוברת ב-<span>$latex q_{k}$</span> בדיוק <span>$latex t$</span> פעמים, אז אפשר לפרק אותה כך: <span>$latex w=uzv$</span> כך ש-<span>$latex z\in\left(L_{q_{k},q_{k}}^{k-1}\right)^{t-1}$</span>. הפעם ה-<span>$latex t-1$</span> שמופיע למעלה הוא לא אינדקס אלא כן בא על תקן חזקה של שפה.</p>

<p>מה המסקנה? כדי לתאר את כל המילים ב-<span>$latex w\in L_{q,p}^{k}\backslash L_{q,p}^{k-1}$</span> אנחנו רוצים לתאר את כל המילים שהן <strong>שרשור</strong> של מילה אחת מתוך <span>$latex L_{q,q_{k}}^{k-1}$</span>, מילה אחת מתוך <span>$latex L_{q_{k},p}^{k-1}$</span>, וביניהן מילה אחת מתוך אחת מהחזקות האפשריות של <span>$latex L_{q_{k},q_{k}}^{k-1}$</span> - כל חזקה אפשרית. האם אנחנו מכירים פעולה שנותנת לנו את זה? בוודאי - זו <strong>בדיוק</strong> הפעולה של סגור-קלייני! אמרתי לכם שנבין סוף סוף למה <strong>בדיוק</strong> צריך את הפעולה הזו? הנה, זו הנקודה המדוייקת שבה היא צצה מעצמה.</p>

<p>נסכם. קיבלנו את המשוואה <span>$latex L_{q,p}^{k}=L_{q,p}^{k-1}\cup L_{q,q_{k}}^{k-1}\left(L_{q_{k},q_{k}}^{k-1}\right)^{*}L_{q_{k},p}^{k-1}$</span>, והמשוואה הזו מסיימת את ההוכחה, כי היא מתארת את היצירה של <span>$latex L_{q,p}^{k}$</span> מתוך שפות שאנחנו כבר יודעים ששייכות לקבוצה האינדוקטיבית שלנו, בעזרת פעולות הסגור שלנו (איחוד, שרשור וסגור-קלייני). בדרך כלל אני לא נוהג להתלהב ממשוואות כי זו לא הפואנטה במתמטיקה, אבל את המשוואה הזו אני אוהב בגלל הסיפור הציורי שהיא מספרת (כל הקטע הזה של “עובר ב-<span>$latex q_{k}$</span> בדיוק כך-וכך פעמים”). אני מקווה שאתם מסכימים.</p>

  </div>

  <hr />
  <p>
    נהניתם? התעניינתם? אם תרצו, אתם מוזמנים לתת טיפ:
  </p>
  <a href='https://ko-fi.com/H2H5XFBQ' target='_blank'><img height='36' style='border:0px;height:36px;' src='https://az743702.vo.msecnd.net/cdn/kofi2.png?v=2' border='0' alt='Buy Me a Coffee at ko-fi.com' /></a><a class="u-url" href="/blog/2014/12/24/regular_languages_kleene_theorem" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">לא מדויק</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">לא מדויק</li><li><a class="u-email" href="mailto:gadial@gmail.com">gadial@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://www.facebook.com/%D7%9C%D7%90-%D7%9E%D7%93%D7%95%D7%99%D7%A7-163347110378474"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#facebook"></use></svg> <span class="username"></span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>בלוג על מתמטיקה ומדעי המחשב</p>
      </div>
    </div>

  </div>

</footer>

<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script>window.jQuery || document.write('<script src="/blogassets/js/jquery-slim.min.js"><\/script>')</script><script src="/blog/assets/js/bootstrap.bundle.js"></script></body>

</html>
