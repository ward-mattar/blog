<!DOCTYPE html>
<html lang="he" dir="rtl"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>אנליזה וקטורית - מציאת ערכי קיצון | לא מדויק</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="אנליזה וקטורית - מציאת ערכי קיצון" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="חלק ראשון, שבו אנו מוצאים ערכי קיצון מקומיים אחד מהשימושים הראשונים של החשבון הדיפרנציאלי והאינטגרלי, שאפשר להציג כבר בשלב מוקדם יחסית, כבר אחרי שראינו מהי נגזרת, הוא פתרון בעיות אופטימיזציה. למשל, מה הזווית הטובה ביותר שבה כדאי לזרוק כדור אם אנחנו רוצים למקסם את המרחק שהוא יגיע אליו. בבעיות כאלו יש לנו מערכת שההתנהגות שלה תלויה בפרמטר כלשהו (“הזווית שבה זורקים את הכדור”), ועבור ערכים שונים של הפרמטר אנחנו מקבלים “תוצאה” שהיא ערך מספרי כלשהו של המערכת (“המרחק שאליו הכדור מגיע”) ואנחנו רוצים למצוא את הערך הטוב ביותר של הפרמטר מבחינתנו. לפעמים זה הערך שעבורו התוצאה היא הגדולה ביותר, ולפעמים זה הערך שעבורו התוצאה היא הקטנה ביותר, תלוי באופי הבעיה (לפעמים הערך הוא ה”מחיר” שאנחנו צריכים לשלם). בעיות אופטימיזציה צצות בתחומים שונים ומשונים במתמטיקה ויש טכניקות שונות ומשונות לטפל בהן. לעתים קרובות מאוד יש לנו אילוצים על הפרמטרים שהמערכת יכולה לקבל, ושקלול שלהם פנימה הוא חלק רציני מפתרון הבעיה." />
<meta property="og:description" content="חלק ראשון, שבו אנו מוצאים ערכי קיצון מקומיים אחד מהשימושים הראשונים של החשבון הדיפרנציאלי והאינטגרלי, שאפשר להציג כבר בשלב מוקדם יחסית, כבר אחרי שראינו מהי נגזרת, הוא פתרון בעיות אופטימיזציה. למשל, מה הזווית הטובה ביותר שבה כדאי לזרוק כדור אם אנחנו רוצים למקסם את המרחק שהוא יגיע אליו. בבעיות כאלו יש לנו מערכת שההתנהגות שלה תלויה בפרמטר כלשהו (“הזווית שבה זורקים את הכדור”), ועבור ערכים שונים של הפרמטר אנחנו מקבלים “תוצאה” שהיא ערך מספרי כלשהו של המערכת (“המרחק שאליו הכדור מגיע”) ואנחנו רוצים למצוא את הערך הטוב ביותר של הפרמטר מבחינתנו. לפעמים זה הערך שעבורו התוצאה היא הגדולה ביותר, ולפעמים זה הערך שעבורו התוצאה היא הקטנה ביותר, תלוי באופי הבעיה (לפעמים הערך הוא ה”מחיר” שאנחנו צריכים לשלם). בעיות אופטימיזציה צצות בתחומים שונים ומשונים במתמטיקה ויש טכניקות שונות ומשונות לטפל בהן. לעתים קרובות מאוד יש לנו אילוצים על הפרמטרים שהמערכת יכולה לקבל, ושקלול שלהם פנימה הוא חלק רציני מפתרון הבעיה." />
<link rel="canonical" href="http://localhost:4000/blog/2015/10/15/vector_calculus_critical_points" />
<meta property="og:url" content="http://localhost:4000/blog/2015/10/15/vector_calculus_critical_points" />
<meta property="og:site_name" content="לא מדויק" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-10-15T18:55:49+03:00" />
<script type="application/ld+json">
{"headline":"אנליזה וקטורית - מציאת ערכי קיצון","dateModified":"2015-10-15T18:55:49+03:00","datePublished":"2015-10-15T18:55:49+03:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/2015/10/15/vector_calculus_critical_points"},"url":"http://localhost:4000/blog/2015/10/15/vector_calculus_critical_points","description":"חלק ראשון, שבו אנו מוצאים ערכי קיצון מקומיים אחד מהשימושים הראשונים של החשבון הדיפרנציאלי והאינטגרלי, שאפשר להציג כבר בשלב מוקדם יחסית, כבר אחרי שראינו מהי נגזרת, הוא פתרון בעיות אופטימיזציה. למשל, מה הזווית הטובה ביותר שבה כדאי לזרוק כדור אם אנחנו רוצים למקסם את המרחק שהוא יגיע אליו. בבעיות כאלו יש לנו מערכת שההתנהגות שלה תלויה בפרמטר כלשהו (“הזווית שבה זורקים את הכדור”), ועבור ערכים שונים של הפרמטר אנחנו מקבלים “תוצאה” שהיא ערך מספרי כלשהו של המערכת (“המרחק שאליו הכדור מגיע”) ואנחנו רוצים למצוא את הערך הטוב ביותר של הפרמטר מבחינתנו. לפעמים זה הערך שעבורו התוצאה היא הגדולה ביותר, ולפעמים זה הערך שעבורו התוצאה היא הקטנה ביותר, תלוי באופי הבעיה (לפעמים הערך הוא ה”מחיר” שאנחנו צריכים לשלם). בעיות אופטימיזציה צצות בתחומים שונים ומשונים במתמטיקה ויש טכניקות שונות ומשונות לטפל בהן. לעתים קרובות מאוד יש לנו אילוצים על הפרמטרים שהמערכת יכולה לקבל, ושקלול שלהם פנימה הוא חלק רציני מפתרון הבעיה.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link href="/blog/assets/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  <link rel="stylesheet" href="/blog/assets/css/main.css">
  <link rel="shortcut icon" href="/blog/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/blog/favicon.ico" type="image/x-icon"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/blog/feed.xml" title="לא מדויק" /><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$latex','$'] ],
        processEscapes: true
      },
       TeX: {extensions: ["AMSmath.js","AMSsymbols.js"]}
    });
  </script>
  <!-- "https://www.gadial.net/wp-includes/js/xypic.js" -->

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
  
</head>
<body><header>
  <nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark">
    <a class="navbar-brand" href="/blog/main">לא מדויק</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarCollapse">
      <ul class="navbar-nav mr-auto">
        
            
            <li class="nav-item">
                <a class="nav-link" href="/blog/main">דף הבית</a>
            </li>
            
        
            
            <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="dropdown1" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">נושאים</a>
            <div class="dropdown-menu" aria-labelledby="dropdown1">
            
            <a class="dropdown-item text-right" href="/blog/analysis">אנליזה</a>
            
            <a class="dropdown-item text-right" href="/blog/algebra">אלגברה</a>
            
           </div>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/blog/categories">קטגוריות</a>
            </li>
            
        
            
            <li class="nav-item">
                <a class="nav-link" href="/blog/about/">אודות</a>
            </li>
            
        
      </ul>
      <form class="form-inline mt-2 mt-md-0" action="post_list.html" method="get">
        <input class="form-control mr-sm-2" type="text" placeholder="חיפוש" aria-label="חיפוש" name="s">
        <button class="btn btn-outline-success my-2 my-sm-0" type="submit">חיפוש</button>
      </form>
    </div>
  </nav>
</header><main class="page-content" aria-label="Content" role="main">
      <div class="wrapper text-right">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">אנליזה וקטורית - מציאת ערכי קיצון</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2015-10-15T18:55:49+03:00" itemprop="datePublished">Oct 15, 2015
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2>חלק ראשון, שבו אנו מוצאים ערכי קיצון מקומיים</h2>
<p>אחד מהשימושים הראשונים של החשבון הדיפרנציאלי והאינטגרלי, שאפשר להציג כבר בשלב מוקדם יחסית, כבר אחרי שראינו מהי נגזרת, הוא פתרון <strong>בעיות אופטימיזציה</strong>. למשל, מה הזווית הטובה ביותר שבה כדאי לזרוק כדור אם אנחנו רוצים למקסם את המרחק שהוא יגיע אליו. בבעיות כאלו יש לנו מערכת שההתנהגות שלה תלויה בפרמטר כלשהו (“הזווית שבה זורקים את הכדור”), ועבור ערכים שונים של הפרמטר אנחנו מקבלים “תוצאה” שהיא ערך מספרי כלשהו של המערכת (“המרחק שאליו הכדור מגיע”) ואנחנו רוצים למצוא את הערך הטוב ביותר של הפרמטר מבחינתנו. לפעמים זה הערך שעבורו התוצאה היא הגדולה ביותר, ולפעמים זה הערך שעבורו התוצאה היא הקטנה ביותר, תלוי באופי הבעיה (לפעמים הערך הוא ה”מחיר” שאנחנו צריכים לשלם). בעיות אופטימיזציה צצות בתחומים שונים ומשונים במתמטיקה ויש טכניקות שונות ומשונות לטפל בהן. לעתים קרובות מאוד יש לנו <strong>אילוצים</strong> על הפרמטרים שהמערכת יכולה לקבל, ושקלול שלהם פנימה הוא חלק רציני מפתרון הבעיה.</p>

<p>מה שמתעסקים איתו בחדו”א הוא סיטואציה פשוטה יחסית, שבה המערכת מתוארת על ידי פונקציה <span>$latex f:\mathbb{R}\to\mathbb{R}$</span> שהיא “נחמדה”, במובן זה שהיא גזירה. הרעיון הוא שאפשר להשתמש בנגזרת של <span>$latex f$</span> כדי לאתר מייד את כל נקודות המקסימום ומינימום <strong>הנקודתיות</strong> של הפונקציה; ובתקווה, אם אין הרבה כאלו, בדיקה קצרה תעלה מה מהן היא המבוקשת שלנו (שעבורה הערך הוא הטוב ביותר אבסולוטית עבור בחירת פרמטרים חוקית). זה לא עובד תמיד טוב, אבל זה עובד טוב מספיק כדי שזה יהיה שימושי ביותר. הטכניקה עצמה מאוד פשוטה - בכל נקודת קיצון מקומית של הפונקציה, הנגזרת שלה חייבת להתאפס (ההפך לאו דווקא נכון). הסיבה פשוטה: ניקח למשל נקודת מקסימום מקומית. כל עוד הפונקציה “עדיין לא הגיעה” אל נקודת המקסימום אבל היא קרובה אליה, היא <strong>עולה</strong> אליה; ומייד אחרי נקודת המקסימום היא <strong>יורדת</strong> ממנה. זה אומר שממש לפני ההגעה לנקודת הקיצון הנגזרת היא <strong>חיובית</strong> ומייד אחרי היא <strong>שלילית</strong>. זה מכריח את הנגזרת באותה נקודה להיות “בו זמנית חיובית ושלילית”, כלומר בהכרח 0.</p>

<p>בסדרת הפוסטים הנוכחית אנחנו מתעסקים באנליזה וקטורית, כלומר בפונקציות ממשיות מרובות משתנים. אז יש לנו פונקציה <span>$latex f:\mathbb{R}^{n}\to\mathbb{R}$</span> ואנחנו רוצים לפתור את אותה בעיה - למצוא נקודות קיצון. קל לחשוב על הנקודות הללו בצורה ציורית כאשר <span>$latex n=2$</span> - אפשר לחשוב על <span>$latex f$</span> כאילו היא מתארת <strong>מפה טופוגרפית</strong>, במובן זה שלכל נקודה <span>$latex \left(x,y\right)$</span> במפה הדו-ממדית נתון לנו גם ה<strong>גובה</strong> של אותה נקודה, <span>$latex f\left(x,y\right)$</span>. נקודת מקסימום היא “פסגת הר” ונקודת מינימום היא “תחתית עמק”. וזה מה שאנחנו רוצים למצוא.</p>

<p>הניחוש הנאיבי ביותר הוא שאותה אינדיקציה שעבדה במימד אחד תעבוד גם ב-<span>$latex n$</span> ממדים: אם יש לפונקציה נקודת קיצון ב-<span>$latex a\in\mathbb{R}^{n}$</span>, אז <span>$latex Df\left(a\right)=0$</span> (כאשר כאן <span>$latex 0$</span> מציין את <strong>טרנספורמציית האפס</strong>, טרנספורמציה לינארית שמחזירה 0 עבור הכל). למרבה השמחה, הניחוש הנאיבי הזה עובד, ואוכיח זאת עוד רגע; למרבה הצער, בכל זאת יש חלק קשה יותר, והוא ה<strong>סיווג</strong> של נקודות הקיצון הפוטנציאליות, שמטרתו להכריע מי הן נקודות הקיצון האמיתיות ומי הן אנומליות לא קשורות.</p>

<p>בואו ניתן כמה הגדרות פורמליות. כרגיל, כל מה שאנחנו מניחים על <span>$latex f$</span> הוא שהיא מוגדרת על קבוצה פתוחה <span>$latex U\subseteq\mathbb{R}^{n}$</span>; אין צורך להניח שהיא מוגדרת בכל מקום. עבור <span>$latex f$</span> כזו, אנחנו אומרים ש-<span>$latex a\in U$</span> היא <strong>נקודת מקסימום מקומית</strong> אם קיימת סביבה <span>$latex V$</span> של <span>$latex a$</span> ב-<span>$latex U$</span> (“סביבה” היא קבוצה פתוחה שמכילה את <span>$latex a$</span>) כך ש-<span>$latex f\left(a\right)\ge f\left(x\right)$</span> לכל <span>$latex x\in V$</span>. באופן דומה מגדירים גם נקודות מינימום.</p>

<p>עכשיו, בואו נגדיר <strong>נקודה קריטית</strong> של <span>$latex f$</span> בתור נקודה <span>$latex a$</span> שבה <span>$latex f$</span> אינה גזירה, או שהיא גזירה אבל <span>$latex Df\left(a\right)=0$</span>. המשפט הראשון שלנו אומר שאם <span>$latex a$</span> היא נקודת קיצון אז היא נקודה קריטית; אבל יכולות להיות נקודות קריטיות שאינן נקודות קיצון, וקוראים להן <strong>נקודות אוכף</strong> (כי נקודה שנמצאת על מושב האוכף היא דוגמה יפה לנקודה שבה הנגזרת מתאפסת אבל היא אינה נקודת קיצון). האתגר יהיה לזהות, בהינתן נקודה קריטית, האם היא נקודת קיצון או לא.</p>

<p>ההוכחה שנקודת קיצון היא קריטית מתבססת על <strong>רדוקציה</strong> למקרה החד ממדי. אם הפונקציה לא גזירה בנקודה, אז על פי הגדרה הנקודה היא נקודת קיצון; לכן אני מניח ש-<span>$latex Df\left(a\right)$</span> מוגדרת. כדי להראות ש-<span>$latex Df\left(a\right)=0$</span> אני צריך להוכיח שהטרנספורמציה הזו מחזירה 0, לא משנה על איזה וקטור היא מופעלת. ומה זו “הפעלה” של הנגזרת על וקטור <span>$latex u$</span>? אם תזכרו, כי דיברנו על זה מזמן מזמן, זה מה שנותן לנו את <strong>הנגזרת המכוונת</strong> של <span>$latex f$</span> בכיוון <span>$latex h$</span>, שהוגדרה כך: <span>$latex \lim_{h\to0}\frac{f\left(a+hu\right)-f\left(a\right)}{h}$</span>. עכשיו, בואו נגדיר פונקציה <span>$latex \phi:\mathbb{R}\to\mathbb{R}$</span> על ידי <span>$latex \phi\left(h\right)=f\left(a+hu\right)$</span>. אז קיבלנו ש-</p>

<p><span>$latex Df\left(a\right)\cdot u=\lim_{h\to0}\frac{f\left(a+hu\right)-f\left(a\right)}{h}=\lim_{h\to0}\frac{\phi\left(h\right)-\phi\left(0\right)}{h}=\phi^{\prime}\left(0\right)$</span></p>

<p>עכשיו, אם <span>$latex a$</span> היא נקודת קיצון של <span>$latex f$</span>, אז <span>$latex 0$</span> היא נקודת קיצון של <span>$latex \phi$</span>, ולכן <span>$latex \phi^{\prime}\left(0\right)=0$</span> (מהמשפט על נקודת קיצון במקרה החד ממדי), וסיימנו: ראינו ש-<span>$latex Df\left(a\right)\cdot u=0$</span> לכל <span>$latex u$</span> ולכן <span>$latex Df\left(a\right)=0$</span>. אז זה היה קל, כמובטח. מה הלאה?</p>

<p>בואו נראה שתי דוגמאות פשוטות כדי לקבל תחושה של נקודת קיצון אל מול נקודת אוכף. נתחיל מ-<span>$latex f\left(x,y\right)=x^{2}+y^{2}$</span> - גרף של הפונקציה הזו נראה כמו מין קערית שכזו. הגרדיאנט קל לחישוב: <span>$latex \nabla f=\left(2x,2y\right)$</span>. הוא מתאפס בדיוק בנקודה אחת: <span>$latex x=y=0$</span>. לכן זו הנקודה היחידה שעשויה להיות נקודת קיצון, וקל לראות במקרה הזה שמדובר על נקודת מינימום. מסקנה: אין נקודות מקסימום בכלל, אחרת היינו מקבלים עוד נקודות קריטיות.</p>

<p>עכשיו בואו נעבור לדבר על האוכף. נתבונן ב-<span>$latex f\left(x,y\right)=x^{2}y+y^{2}x$</span>. הגרדיאנט שלה הוא <span>$latex \nabla f=\left(2xy+y^{2},2yx+x^{2}\right)$</span>. אז קיבלנו מערכת של שתי משוואות בשני נעלמים עבור <span>$latex \nabla f=0$</span>. אם <span>$latex y=0$</span> אז <span>$latex 2yx+x^{2}=0$</span> גורר ש-<span>$latex x=0$</span> ולכן פרט לנקודת הקיצון הברורה ב-<span>$latex x=y=0$</span> אנחנו יכולים להניח בהמשך הניתוח ש-<span>$latex x\ne0$</span> וגם <span>$latex y\ne0$</span> ולכן אפשר לחלק בהם. כעת, אם <span>$latex 2xy+y^{2}=0$</span> נחלק ב-<span>$latex y$</span> ונקבל <span>$latex y=-2x$</span>, ובאופן סימטרי <span>$latex x=-2y$</span> מתקבל מהמשוואה השניה. קיבלנו <span>$latex x=-2y=4x$</span>, מה שגורר <span>$latex x=0$</span>, וזו סתירה להנחה שלנו שהוא שונה; לכן הנקודה הקריטית היחידה היא <span>$latex x=y=0$</span>. קל לראות שזו לא נקודת קיצון על ידי הסתכלות בישר <span>$latex x=y$</span>: עליו, הפונקציה היא <span>$latex \phi\left(x\right)=f\left(x,x\right)=2x^{3}$</span> ולכן עבור <span>$latex x&gt;0$</span> נקבל ערך חיובי ועבור <span>$latex x&lt;0$</span> נקבל ערך שלילי, ומכאן ש-<span>$latex \left(0,0\right)$</span> היא לא נקודת קיצון. זו סיטואציה דומה למה שקורה במימד אחד עם, למשל, <span>$latex \tan x$</span>.</p>

<p>אז איך מבדילים בין נקודת קיצון ובין “סתם” נקודה קריטית? בחדו”א של משתנה יחיד היה מבחן שעבד טוב במקרה שבו הפונקציה היא “נחמדה מספיק” - אם היא הייתה גזירה פעמיים, אז הנגזרת השניה שלה נתנה לנו את המידע הדרוש. אם הנגזרת השניה בנקודה הקריטית הייתה חיובית, הנקודה הייתה נקודת מינימום; אם היא הייתה שלילית, זו הייתה נקודת מקסימום; ואם היא הייתה 0 אז זו הייתה נקודה קריטית שאינה נקודת קיצון.</p>

<p>האינטואיציה כאן היתה פשוטה. בנקודת מינימום, רגע לפני הנקודה הפונקציה <strong>יורדת</strong>, כלומר בעלת נגזרת שלילית; רגע אחרי הנקודה הפונקציה <strong>עולה</strong>, כלומר בעלת נגזרת חיובית; זה אומר שבסביבות הנקודה, ה<strong>נגזרת</strong> היא פונקציה עולה (בהתחלה שלילית, אחר כך 0, לבסוף חיובית). אם היא פונקציה עולה, אז הנגזרת <strong>שלה</strong> היא חיובית. שיקול דומה מטפל גם בנקודת מקסימום. ומה קרה ב-<span>$latex \tan x$</span>, למשל? הפונקציה היא עולה <strong>כל הזמן</strong>, כלומר הנגזרת היא חיובית כל הזמן (למעט בנקודה הקריטית עצמה, שם היא 0). אבל בהתחלה הנגזרת היא פונקציה יורדת (מתחילה מאוד גדולה ולאט לאט קטנה עד שהיא מגיעה ל-0) ואחרי הנקודה הקריטית היא מתחילה לעלות מחדש. כלומר, בנקודה הקריטית הנגזרת היא חיובית <strong>קודם</strong> וחיובית <strong>אחר כך</strong>, כלומר הנקודה הקריטית היא <strong>נקודת מינימום</strong> של הנגזרת, ולכן הנגזרת השניה היא 0.</p>

<p>היינו שמחים להכליל את הטיעון הזה ל-<span>$latex n$</span> ממדים, וזה אכן מה שנעשה; אפשר להסיק את הקריטריון החד ממדי מהתוצאה שנראה. אבל למרבה הצער, הקריטריון שלנו יהיה <strong>מסובך</strong> משמעותית יותר מאשר במקרה החד משמעי, ודורש היכרות עם אלגברה לינארית. הקושי הוא בכך שאנחנו צריכים למצוא הכללה כלשהי ל”נגזרת השניה” של מימד אחד. הרי אצלנו “נגזרת” היא כבר לא פונקציה <span>$latex f:\mathbb{R}^{n}\to\mathbb{R}$</span> כמו הפונקציה שאותה גזרנו; היא אופרטור שלכל נקודה במרחב מתאים <strong>טרנספורמציה לינארית</strong> (או מטריצה, איך שתעדיפו להסתכל על זה), ואי אפשר לגזור את זה. אז אנחנו משתמשים במשהו אחר - מטריצה <span>$latex n\times n$</span> שכוללת את כל <strong>הנגזרות החלקיות המעורבות מסדר שני</strong>. המטריצה הזו נקראת <strong>הסיאן</strong>.</p>

<p>מה זו נגזרת חלקית אנחנו כבר יודעים - פשוט גוזרים את הפונקציה רק על פי משתנה בודד ומתייחסים ליתר בתור פרמטרים. ראינו כבר שאם <span>$latex f$</span> גזירה אז הנגזרת שלה ניתנת לתיאור בתור וקטור הנגזרות החלקיות של <span>$latex f$</span>. נגזרת חלקית “מסדר שני” היא מה שמתקבל כשגוזרים נגזרת חלקית שוב, ו”מעורבת” אומר שאפשר לגזור שוב על פי כל אחד מהמשתנים. אני מסמן <span>$latex \frac{\partial^{2}f}{\partial x\partial y}$</span> את מה שמתקבל כשאני גוזר את <span>$latex f$</span> קודם כל לפי המשתנה <span>$latex x$</span> ואז לפי המשתנה <span>$latex y$</span>. למשל, עבור פונקציית נקודת האוכף <span>$latex f\left(x,y\right)=x^{2}y+y^{2}x$</span> אנחנו יודעים ש-<span>$latex \frac{\partial f}{\partial x}=2xy+y^{2}$</span>, ולכן אם נגזור שוב לפי <span>$latex y$</span>, נקבל ש-<span>$latex \frac{\partial^{2}f}{\partial x\partial y}=2x+2y$</span>.</p>

<p>מטריצת הסיאן מתקבלת באופן דומה - הכניסה בשורה ה-<span>$latex i$</span> ובעמודה ה-<span>$latex j$</span> שווה לנגזרת החלקית קודם לפי המשתנה <span>$latex x_{i}$</span> ואחר כך לפי המשתנה <span>$latex x_{j}$</span>, כלומר <span>$latex \left[H\right]_{ij}=\frac{\partial^{2}f}{\partial x_{i}\partial x_{j}}$</span>. אם נכתוב את ההסיאן של <span>$latex f\left(x,y\right)=x^{2}+y^{2}$</span> נקבל <span>$latex \left[\begin{array}{cc}2 &amp; 0\\0 &amp; 2\end{array}\right]$</span>. אם נכתוב את ההסיאן של <span>$latex f$</span> של נקודת האוכף, נקבל <span>$latex \left[\begin{array}{cc}2y &amp; 2x+2y\\2x+2y &amp; 2x\end{array}\right]$</span>. שימו לב שזו מטריצה <strong>סימטרית</strong>, כלומר יוצא שהנגזרת המעורבת קודם לפי <span>$latex x$</span> ואז על פי <span>$latex y$</span> שווה לנגזרת המעורבת קודם על פי <span>$latex y$</span> ואז על פי <span>$latex x$</span>; זה לא מקרי וזה תמיד מתקיים אם שתי הנגזרות המעורבות הללו הן רציפות; אנחנו נניח מעכשיו ש-<span>$latex f$</span> היא ב-<span>$latex C^{2}$</span>, אחרת המשפט שאני מתאר לא יהיה נכון.</p>

<p>עכשיו אפשר לנסח את הקריטריון שלנו בלשון שאותה יבינו מי שמכירים אלגברה לינארית: אם בנקודה הקריטית ההסיאן הוא <strong>מטריצה חיובית לחלוטין</strong> (Positive Definite Matrix), אז הנקודה הקריטית היא נקודת מינימום; ואם ההסיאן הוא <strong>מטריצה שלילית לחלוטין</strong> (Negative Definite Matrix) אז הנקודה הקריטית היא נקודת מקסימום; ואחרת אין לנו מושג מהי הנקודה הקריטית. מן הסתם המושג המרכזי פה הוא “חיובית/שלילית לחלוטין” שתכף אסביר, אבל למי שרוצים את התכל’ס, תנאי שקול לכך שמטריצה תהיה חיובית לחלוטין הוא שכל הערכים העצמיים שלה יהיו חיוביים, ואילו עבור שלילית לחלוטין, שכולם יהיו שליליים. זה מסביר את התוצאה בשתי הדוגמאות שראינו; במקרה הראשון קיבלנו מטריצה שהערך העצמי היחיד שלה הוא 2 החיובי, ולכן הנקודה הקריטית היא נקודת מינימום; ובמקרה השני ההסיאן ב-<span>$latex x=y=0$</span> הוא מטריצת האפס, שהערך העצמי היחיד שלה הוא 0 שאינו חיובי או שלילי.</p>

<p>הנה הסבר קצר לגבי מה זה מוגדרת חיובית ולמה זה רלוונטי פה, בלי להיכנס להוכחות עד הסוף. אם אין לכם כוח אליו אתם מוזמנים לדלג להמשך, שבו מדברים על כופלי לגראנז’ שהם נושא נפרד ומגניב וחשוב בפני עצמו.</p>

<p>אנחנו יודעים שכל מטריצה <span>$latex A$</span> מסדר <span>$latex n\times n$</span> מעל שדה <span>$latex \mathbb{F}$</span> מגדירה טרנספורמציה לינארית <span>$latex T_{A}:\mathbb{F}^{n}\to\mathbb{F}^{n}$</span>. אבל יש עוד סוג מעניין של העתקה בערך-לינארית שהמטריצה מגדירה: <strong>תבנית בילינארית</strong>, שהיא פונקציה <span>$latex B_{A}:\mathbb{F}^{n}\times\mathbb{F}^{n}\to\mathbb{F}$</span> שלינארית בכל אחד משני הרכיבים שלה בנפרד, ומוגדרת על ידי <span>$latex B\left(v,u\right)=v^{t}Au$</span> (כלומר, כופלים את המטריצה <span>$latex A$</span> בוקטור העמודה <span>$latex u$</span> כרגיל ומקבלים וקטור ב-<span>$latex \mathbb{F}^{n}$</span>, אבל אחר כך כופלים את התוצאה הזו גם בוקטור השורה <span>$latex v^{t}$</span>, דהיינו מבצעים מכפלה סקלרית של <span>$latex v$</span> ושל <span>$latex Au$</span>). כל תבנית בילינארית מגדירה, בתורה, גם פונקציה <span>$latex g:\mathbb{F}^{n}\to\mathbb{F}$</span> על ידי <span>$latex g_{A}\left(v\right)=B_{A}\left(v,v\right)=v^{t}Av$</span> (במילים, כופלים סקלרית את <span>$latex v$</span> בתמונה של <span>$latex v$</span> על ידי הטרנספורמציה הלינארית שמוגדרת על ידי <span>$latex A$</span>). לפונקציה כזו קוראים <strong>תבנית ריבועית</strong> והיא מה שמעניין אותנו כאן. דוגמה פשוטה לתבנית בילינארית היא <strong>מכפלה פנימית</strong>, ודוגמה פשוטה לתבנית ריבועית שמוגדרת על ידה היא <strong>נורמה</strong> (כמעט; כזכור, נורמה היא השורש של מכפלה פנימית של וקטור עם עצמו). תבניות בילינאריות וריבועיות מופיעות באינספור מקומות במתמטיקה, הגם שהן קצת פחות נפוצות מטרנספורמציות לינאריות, ולרוב מגיעים אליהן רק בקורס שני באלגברה לינארית.</p>

<p>עכשיו בואו נעזוב את האלגברה הלינארית הכללית ונזכור שאנחנו מדברים על המקרה שבו <span>$latex \mathbb{F}=\mathbb{R}$</span>. בממשיים יש <strong>יחס סדר</strong> - אפשר להגיד “חיובי” ו”שלילי” (אפילו ב-<span>$latex \mathbb{C}$</span> אי אפשר להגיד דברים כאלו). זה מוביל אותנו להגדרה שאנחנו רוצים - <span>$latex A$</span> היא מטריצה חיובית לחלוטין אם התבנית הריבועית שהיא מגדירה מקיימת ש-<span>$latex g_{A}\left(x\right)&gt;0$</span> לכל <span>$latex x\ne0$</span> (עבור <span>$latex x=0$</span> תמיד נקבל <span>$latex g_{A}\left(x\right)=0$</span>, כמובן). בדומה <span>$latex A$</span> היא שלילית לחלוטין אם <span>$latex g_{A}\left(x\right)&lt;0$</span> לכל <span>$latex x\ne0$</span>. עבור מטריצה מסדר <span>$latex 1\times1$</span> הקריטריון הזה שקול לכך שהכניסה היחידה של המטריצה תהיה חיובית/שלילית (כי אם <span>$latex A=\left[a\right]$</span> אז נקבל ש-<span>$latex g_{A}\left(x\right)=a\cdot x^{2}$</span>) ולכן קיבלנו פה הכללה של התוצאה עבור <span>$latex n=1$</span>.</p>

<p>כדי להבין למה זה עובד ומאיפה <span>$latex H$</span> הגיעה בכלל אני צריך לשלוף מהכובע שפן שלפחות לעת עתה בחרתי לא לתת לו פוסט, אבל אולי בעתיד כן - <strong>פולינומי טיילור</strong>. <a href="http://www.gadial.net/2010/03/27/exponent/">תיארתי אותם פעם</a> בבלוג במקרה החד ממדי, וכנראה שכדאי לתאר אותם בפירוט גם במקרה הרב ממדי, אבל לבינתיים אסתפק בהסבר קצר. כזכור, פולינום טיילור “רגיל” מאפשר לנו לקרב פונקציות מסובכות על ידי פולינומים שמחושבים מתוך כל הנגזרות של הפונקציה בנקודה מסויימת ש”סביבה” מפתחים אותה. פורמלית, <span>$latex f\left(x_{0}+h\right)=\sum_{k=0}^{n}\frac{f^{\left(k\right)}\left(x_{0}\right)}{k!}h^{k}+R_{n+1}\left(x_{0},h\right)$</span>, כאשר <span>$latex \sum_{k=0}^{n}\frac{f^{\left(k\right)}\left(x_{0}\right)}{k!}h^{k}$</span> הוא הפולינום, ואילו <span>$latex R_{n+1}\left(x_{0},h\right)$</span> היא פונקציית ה”שארית” שמתארת את הטעות של הפולינום (ומן הסתם לב העניין הוא לחסום את הגודל שלה, מה שיוצא שונה עבור פונקציות שונות ונקודות פיתוח שונות). לפעמים פשוט כותבים טור חזקות אינסופי, <span>$latex \sum_{n=0}^{\infty}\frac{f^{\left(n\right)}\left(x_{0}\right)}{n!}h^{n}$</span>, אבל עם הכתיב הזה צריך להיזהר כי לא בהכרח ברור עבור אילו ערכים של <span>$latex h$</span> הטור הזה מתכנס בכלל (עבור <span>$latex h=0$</span> הוא מתכנס תמיד, אבל פרט לכך? הדיון על <strong>רדיוס ההתכנסות</strong> של טורי חזקות הוא מעניין בפני עצמו וצריך להציג אותו בבלוג מתישהו) וגם לא ברור שאפילו אם הטור מתכנס, אז <span>$latex f\left(x_{0}+h\right)$</span> שווה לסכום שלו.</p>

<p>פולינומי טיילור של פונקציות <span>$latex f:\mathbb{R}^{n}\to\mathbb{R}$</span> עובדים בצורה דומה, אבל כפי שאתם מנחשים, צריך לזרוק פנימה את כל הנגזרות החלקיות וזה יוצא מתוסבך למדי לכתיבה בלי שמסכימים מראש על כל מני קיצורים. בכל זאת אני לא יכול להתאפק ואציג את הטור המלא של פיתוח סביב <span>$latex \left(a_{1},\dots,a_{n}\right)$</span>:</p>

<p><span>$latex \sum_{k_{1}=0}^{\infty}\cdots\sum_{k_{n}=0}^{\infty}\frac{\partial^{k_{1}}}{\partial x_{1}^{k_{1}}}\cdots\frac{\partial^{k_{n}}}{\partial x_{n}^{k_{n}}}f\left(a_{1},\dots,a_{n}\right)\frac{h_{1}^{k1}\cdots h_{n}^{k_{n}}}{k_{1}!\cdots k_{n}!}$</span></p>

<p>או במילים: כל איבר בטור הזה מתקבל על ידי כך שגוזרים את <span>$latex f$</span> מספר מסויים של פעמים על פי כל משתנה, כופלים את התוצאה בחזקות מתאימות של כניסות <span>$latex \left(h_{1},\dots,h_{n}\right)$</span> ומחלקים בעצרת מתאימה. בואו נראה דוגמה פשוטה עבור פונקציה <span>$latex f\left(x,y\right)$</span> שהיא ב-<span>$latex C^{2}$</span> ולכן <span>$latex \frac{\partial^{2}f}{\partial x\partial y}=\frac{\partial^{2}f}{\partial y\partial x}$</span>; נפתח את הטור עד סדר שני, כלומר עד וכולל ערכי ה-<span>$latex k$</span> שמקיימים <span>$latex k_{1}+k_{2}=2$</span>:</p>

<p><span>$latex f\left(x+h_{1},y+h_{2}\right)=f\left(x,y\right)+\frac{\partial f}{\partial x}\left(x,y\right)h_{1}+\frac{\partial f}{\partial y}\left(x,y\right)h_{2}+\frac{\partial^{2}f}{\partial x^{2}}\left(x,y\right)\frac{h_{1}^{2}}{2}+\frac{\partial^{2}f}{\partial y^{2}}\left(x,y\right)\frac{h_{2}^{2}}{2}+\frac{\partial^{2}f}{\partial x\partial y}\left(x,y\right)h_{1}h_{2}+R_{3}\left(h_{1},h_{2}\right)$</span></p>

<p>ואם יש לנו <span>$latex n$</span> משתנים, הכתיב נשאר דומה:</p>

<p><span>$latex f\left(x_{1}+h_{1},\dots,x_{n}+h_{n}\right)=f\left(x_{1},\dots,x_{n}\right)+\sum_{i=1}^{n}\frac{\partial f}{\partial x_{i}}\left(x_{1},\dots,x_{n}\right)h_{i}+\frac{1}{2}\sum_{i,j=1}^{n}\frac{\partial^{2}f}{\partial x_{i}\partial x_{j}}\left(x_{1},\dots,x_{n}\right)h_{i}h_{j}+R_{3}\left(h_{1},\dots,h_{n}\right)$</span></p>

<p>כאן אנחנו קצת מרמים בסימון אבל מתקנים את זה בו זמנית: למשל, בסכום מופיעים גם <span>$latex \frac{\partial^{2}f}{\partial x_{1}\partial x_{2}}$</span> וגם <span>$latex \frac{\partial^{2}f}{\partial x_{2}\partial x_{1}}$</span> למרות שהאיבר הזה (אלו שתי הצגות שונות לאותו איבר, כי אמרתי שבמקרה שלנו הנגזרות המעורבות שוות) אמור להופיע רק פעם אחת. אז יש לי ספירה כפולה, אבל זה מתקזז עם הכפל ב-<span>$latex \frac{1}{2}$</span> שהוספתי שם (אם תשימו לב, בנוסחה המקורית אם גזרנו פעמיים לפי אותו משתנה צריך לכפול ב-<span>$latex \frac{1}{2!}$</span> ואם גזרנו לפי שני משתנים שונים לא עושים את זה).</p>

<p>את כל זה אפשר לכתוב אפילו עוד יותר בקיצור:</p>

<p><span>$latex f\left(x+h\right)=f\left(x\right)+\nabla f\left(x\right)\cdot h+\frac{1}{2}H_{x}\left(h\right)+R_{3}\left(h\right)$</span></p>

<p>במילים אחרות, הגרדיאנט של <span>$latex f$</span> הוא “האיבר הראשון” בפיתוח טיילור של <span>$latex f$</span>, וההסיאן <span>$latex H$</span> הוא “האיבר השני”. האנלוגיה למקרה החד ממדי (שבו האיבר הראשון בפיתוח הוא הנגזרת הראשונה, והאיבר השני הוא הנגזרת השניה) מובהקת כאן.</p>

<p>איך כל זה רלוונטי לענייננו? כזכור, אנחנו מניחים שב-<span>$latex x$</span> יש ל-<span>$latex f$</span> נקודה קריטית ורוצים לסווג אותה. נקודה קריטית פירושו של דבר ש-<span>$latex \nabla f\left(x\right)=0$</span>, כך שאפשר לכתוב את פיתוח הטיילור גם בתור</p>

<p><span>$latex f\left(x+h\right)-f\left(x\right)=\frac{1}{2}H_{x}\left(h\right)+R_{3}\left(h\right)$</span></p>

<p>נניח שההסיאן ב-<span>$latex x$</span> הוא חיובי לחלוטין, ולכן על פי המשפט אמור לנבוע מכך ש-<span>$latex x$</span> היא נקודת מינימום. אם <span>$latex x$</span> היא נקודת מינימום של <span>$latex f$</span>, אנחנו מצפים שאגף שמאל יהיה חיובי עבור כל ה-<span>$latex h$</span>-ים בסביבה קרובה מספיק של <span>$latex x$</span>. ומה קורה באגף ימין? יש לנו קרב ענקים בין ההסיאן ובין <span>$latex R_{3}\left(h\right)$</span>, השארית. כאן מגיע טיעון אינפי סטנדרטי - אם ניקח <span>$latex h$</span> “מספיק קטן” אז מצד אחד השארית תהיה קטנה מאוד, ומצד שני ההסיאן יחזיר לנו ערך שהוא יחסית גדול <strong>וחיובי</strong>, והערך הזה “ינצח” בתחרות. אני אדלג על המשך ההוכחה כי הוא טכני באופן סטנדרטי ואומר בדיוק את זה; הפואנטה המרכזית היא שבגלל שההסיאן הוא פונקציה “נחמדה” (בילינארית) מקבלים שקיים קבוע <span>$latex M$</span> כלשהי כך ש-<span>$latex H\left(h\right)\ge M\|h\|^{2}$</span> לכל <span>$latex h$</span>, וזה נותן לנו את ה”יחסית גדול וחיובי” שלנו. הפרטים הטכניים פחות קריטיים פה - מה שמעניין בסיפור הזה, לטעמי, הוא מאיפה ההסיאן הזה צץ בכלל; כשברור שזה הרכיב השני בפיתוח הטיילור של הפונקציה, ושהרכיב הראשון איננו עמנו עוד כי אנחנו בנקודה קריטית, העניין נהיה מאוד ברור.</p>
<h2>חלק שני, שבו כל העסק נהיה מאולץ</h2>
<p>בתחילת הפוסט אמרתי שבבעיות אופטימיזציה יש לנו לעתים קרובות <strong>אילוצים</strong> על המערכת, כלומר לא כל פרמטר הוא חוקי. זה מגדיל מייד את רמת הקושי של הבעיה שלנו ועל פניו הופך את כל הטכניקה שראינו עד כה לחסרת תועלת. אתן דוגמה פשוטה. נסתכל על הפונקציה <span>$latex f:\mathbb{R}^{2}\to\mathbb{R}$</span> המוגדרת על ידי <span>$latex f\left(x,y\right)=x$</span>. בבירור אין לה לא נקודת מינימום ולא נקודת מקסימום בשום מקום ולכן הטכניקה שראינו קודם לא תסייע לנו עם העיסוק בה בכלל. מצד שני, אם נוסיף למערכת את האילוץ שהקלטים ל-<span>$latex f$</span> חייבים להילקח רק ממעגל היחידה, אז ברור שפתאום יש ל-<span>$latex f$</span> מקסימום ב-<span>$latex \left(1,0\right)$</span> ומינימום ב-<span>$latex \left(-1,0\right)$</span>. אבל איך מוצאים את זה?</p>

<p>לפני שנפתור את הבעיה הזו, צריך להבין מה המשמעות של “אילוץ”. עבורנו זה אומר שנתונה פונקציה <span>$latex g:\mathbb{R}^{n}\to\mathbb{R}$</span> כלשהי ונתון <span>$latex c\in\mathbb{R}$</span>, ואנחנו מגדירים אילוץ על ידי המשוואה <span>$latex g\left(x\right)=c$</span>. כלומר, מותר לחפש את הפתרון רק בקרב ה-<span>$latex x$</span>-ים שמקיימים <span>$latex g\left(x\right)=c$</span>. בדוגמה שלי, <span>$latex g\left(x,y\right)=x^{2}+y^{2}$</span> ואילו <span>$latex c=1$</span>. כפי שבטח כבר ברור לכם, השיטה הזו להבעת אילוצים היא נוחה מאוד ומאפשרת לתאר שלל יצורים גאומטריים (ראינו כרגע מעגל; קו ישר מתואר על ידי <span>$latex g\left(x,y\right)=ax-by$</span> עבור <span>$latex a,b$</span> כלשהם, וכדומה).</p>

<p>כעת, נניח ש-<span>$latex g$</span> היא פונקציה “נחמדה” - גזירה. נסמן ב-<span>$latex S$</span> את המרחב שמוגדר על ידי <span>$latex S=\left\{ x\in\mathbb{R}^{n}\ |\ g\left(x\right)=c\right\} $</span> (מעכשיו אקרא לו “משטח” כי בתלת מימד משוואות כאלו מגדירות משטחים; שם מדויק יותר למקרה הכללי שבו אני עוסק הוא <strong>יריעה</strong> אבל זה מושג לא טריוויאלי ואני לא רוצה להיכנס להגדרה שלו כרגע), וניקח <span>$latex x_{0}\in S$</span> כלשהו. הנה אבחנה מיידית שבלבלה אותי בצורה יוצאת דופן כשרק למדתי את הנושא הזה: <span>$latex \nabla g\left(x_{0}\right)$</span> הוא <strong>אורתוגונלי</strong> ל-<span>$latex S$</span> בנקודה <span>$latex x_{0}$</span>. הגרדיאנט של הפונקציה שמגדירה את המשטח ניצב למשטח באותה נקודה. למה זה מבלבל? כי לעתים קרובות נהוג להגדיר את הגרדיאנט של פונקציה בנקודה כלשהי בתור הוקטור שמצביע על הכיוון שבו היא “הכי תלולה”. אם הגרדיאנט ניצב למשטח, הוא מצביע על כיוון שבו הפונקציה בכלל לא גדלה, וזה נראה הכי לא נכון שרק אפשר. אז למה זה מסתדר?</p>

<p>זה מסתדר כי עשיתי מיש-מש מכל העסק. הגרדיאנט לא ניצב <strong>לפונקציה</strong>; הוא ניצב <strong>למשטח שהפונקציה מגדירה בצורה מסויימת</strong>. מה שבלבל אותי בשעתו הוא שאפשר להגדיר משטחים בשתי דרכים שונות. דרך אחת, כללית פחות, היא לכתוב <span>$latex z=f\left(x,y\right)$</span> ובכך לתאר את המשטח <span>$latex S=\left\{ \left(x,y,f\left(x,y\right)\right)\ |\ x,y\in\mathbb{R}^{2}\right\} $</span>; הדרך השניה, הכללית יותר, היא לכתוב <span>$latex S=\left\{ \left(x,y,z\right)\ |\ F\left(x,y,z\right)=c\right\} $</span>. שימו לב שבדרך הראשונה אנחנו משתמשים בפונקציה של <strong>שני</strong> משתנים ובשניה בפונקציה של <strong>שלושה</strong> משתנים כדי להגדיר את אותו הדבר - משטח ב-<span>$latex \mathbb{R}^{3}$</span>. אם יש לי פונקציה <span>$latex f:\mathbb{R}^{2}\to\mathbb{R}$</span> ואני רוצה להציג את המשטח שמוגדר על ידה בדרך הראשונה בעזרת דרך ההצגה השניה, אני פשוט אגדיר <span>$latex F\left(x,y,z\right)=z-f\left(x,y\right)$</span> ו-<span>$latex c=0$</span>; לכן דרך ההצגה השניה כללית יותר. היא כללית יותר <strong>ממש</strong> (כלומר, יש דברים שאי אפשר לעשות בדרך הראשונה) כי למשל אני יכול לתאר את כדור היחידה על ידי <span>$latex F\left(x,y,z\right)=x^{2}+y^{2}+z^{2}$</span> ו-<span>$latex c=1$</span>, אבל אין לי דרך לעשות את זה באמצעות הצגת קואורדינטת ה-<span>$latex z$</span> כפונקציה של שתי האחרות (כי עבור אותם <span>$latex x,y$</span> עשויים להיות שני ערכי <span>$latex z$</span> אפשריים שונים על המשטח).</p>

<p>הנה הוכחה זריזה לכך שהגרדיאנט ניצב למשטח שהפונקציה מגדירה. הרעיון הוא לקחת מסלול כלשהו במשטח שעובר דרך <span>$latex x_{0}$</span> ולהראות שהגרדיאנט ב-<span>$latex x_{0}$</span> ניצב אליו. בלי להיכנס לעובי ההגדרות, מסלול הוא פונקציה גזירה <span>$latex c:\left[0,1\right]\to\mathbb{R}^{n}$</span>, ומסלול במשטח <span>$latex S\subseteq\mathbb{R}^{n}$</span> מקיים את הדרישה ש-<span>$latex c\left(\left[0,1\right]\right)\subseteq S$</span>, ונניח ש-<span>$latex c\left(0\right)=x_{0}$</span>. עכשיו, הרעיון במסלול שעובר דרך <span>$latex S$</span> הוא שכל נקודה בו מקיימת את האילוץ שמגדיר את <span>$latex S$</span>. נניח שהאילוץ הזה הוא <span>$latex F\left(x\right)=c$</span>, אז <span>$latex F\left(c\left(t\right)\right)=c$</span> לכל <span>$latex t\in\left[0,1\right]$</span>. עכשיו אפשר להשתמש בכלל השרשרת, לגזור ולקבל ש-<span>$latex DF\left(c\left(0\right)\right)\cdot Dc\left(0\right)=0$</span>, או בסימון קצת שונה, ש-<span>$latex \nabla F\left(x_{0}\right)\cdot c^{\prime}\left(0\right)=0$</span>. עכשיו, <span>$latex c^{\prime}\left(0\right)$</span> הוא בדיוק שיפוע המשיק ל-<span>$latex c$</span> ב-<span>$latex x_{0}$</span>, ואילו <span>$latex \nabla F\left(x_{0}\right)$</span> הוא הגרדיאנט של <span>$latex F$</span>, וקיבלנו שהמכפלה הפנימית שלהם היא 0 - כלומר, הם ניצבים.</p>

<p>עכשיו בואו נפתור את הבעיה של אופטימיזציה-עם-אילוצים. הפתרון הוא סוג של הכללה של מה שראינו קודם. קודם בדקנו איפה הגרדיאנט של <span>$latex f$</span> <strong>מתאפס</strong>. ההכללה שלנו תהיה לבדוק איפה הגרדיאנט של <span>$latex f$</span> שווה ל<strong>צירוף לינארי של האילוצים</strong>. המקדמים של האילוצים נקראים “<strong>כופלי לגראנז'</strong>”, והשיטה נקראת על שמם - שיטת כופלי לגראנז’.</p>

<p>הנה הניסוח הפורמלי. נניח שיש לנו פונקציה <span>$latex f:\mathbb{R}^{n}\to\mathbb{R}$</span> שהיא מה שאנחנו רוצים לאפטמז, ופונקציות אילוצים <span>$latex g_{1},\dots,g_{k}:\mathbb{R}^{n}\to\mathbb{R}$</span> עם קבועים <span>$latex c_{1},\dots,c_{k}$</span> שמגדירות קבוצה <span>$latex S$</span> (כלומר, האילוץ הוא <span>$latex g_{i}\left(x\right)=c_{i}$</span> עבור <span>$latex 1\le i\le k$</span>). נניח ש-<span>$latex x_{0}$</span> היא נקודה שמקיימת את כל האילוצים (<span>$latex g_{i}\left(x_{0}\right)=c_{i}$</span>) וש-<span>$latex \nabla g_{i}\left(x_{0}\right)\ne0$</span>, ושיש ל-<span>$latex f|_{S}$</span> מקסימום או מינימום מקומי ב-<span>$latex x_{0}$</span> (הסימון <span>$latex f|_{S}$</span> פירושו “<span>$latex f$</span> מצומצמת ל-<span>$latex S$</span>”), אז קיימים <span>$latex \lambda_{1},\dots,\lambda_{k}\in\mathbb{R}$</span> כך ש-<span>$latex \nabla f\left(x_{0}\right)=\lambda_{1}\nabla g_{1}\left(x_{0}\right)+\dots+\lambda_{k}\nabla g_{k}\left(x_{0}\right)$</span>. זה אומר שכשאנחנו מחפשים נקודות קיצון, אנחנו מקבלים מערכת של משוואות שנקודות הקיצון חייבות להיכלל בפתרונות שלה.</p>

<p>בואו נראה איך זה עובד במקרה של דוגמת המעגל שנתתי קודם. מכיוון ש-<span>$latex f\left(x,y\right)=x$</span> אז <span>$latex \nabla f=\left(1,0\right)$</span>, ומכיוון ש-<span>$latex g\left(x,y\right)=x^{2}+y^{2}$</span>, אז <span>$latex \nabla g=\left(2x,2y\right)$</span>. משוואת כופלי לגראנז’ נותנת לנו כאן את המשוואה <span>$latex \left(1,0\right)=\lambda\left(2x,2y\right)$</span> שמתורגמת בתורה לשתי משוואות פשוטות:</p>

<p><span>$latex 2x\lambda=1$</span></p>

<p><span>$latex 2y\lambda=0$</span></p>

<p>מהמשוואה הראשונה ברור ש-<span>$latex \lambda\ne0$</span> ולכן מהשניה קיבלנו ש-<span>$latex y=0$</span> הוא הכרחי. הנקודות היחידות שמקיימות את האילוץ <span>$latex g\left(x,y\right)=1$</span> ומקיימות <span>$latex y=0$</span> הן <span>$latex \left(1,0\right)$</span> ו-<span>$latex \left(-1,0\right)$</span> ועבור כל אחת מהן יש, כמובן, <span>$latex \lambda$</span> שפותר את המשוואה. קיבלנו ששתי אלו הן נקודות הקיצון שלנו, וזה אכן מה שהתחלתי ממנו.</p>

<p>חסרים לנו עוד שני דברים - אינטואיציה למה כל זה עובד, והוכחה. את ההוכחה המלאה אני לא אביא כאן, ובמקום זה אתן דגש חזק על הרעיונות הכלליים. הדבר הראשון שצריך להבין הוא שנתתי למעלה את הגרסה ה”שימושית” של המשפט - קחו את הגרדיאנט של <span>$latex f$</span>, אז הוא צירוף לינארי של הגרדיאנטים של האילוצים. זה משהו שקל להשתמש בו פרקטית, אבל זו לאו דווקא הדרך הקלה ביותר לחשוב על המשפט. אז הנה ניסוח <strong>כללי יותר</strong> של המשפט: אם <span>$latex S$</span> הוא משטח, <span>$latex x_{0}\in S$</span> היא נקודה על המשטח ו-<span>$latex f$</span> היא פונקציה כך של-<span>$latex f|_{S}$</span> יש נקודת קיצון ב-<span>$latex x_{0}$</span>, אז <strong>המישור המשיק</strong> ל-<span>$latex S$</span> בנקודה <span>$latex x_{0}$</span> מוכל בגרעין של <span>$latex \nabla f\left(x_{0}\right)$</span>. אם אני אסמן את המישור המשיק ל-<span>$latex S$</span> בנקודה <span>$latex x_{0}$</span> בתור <span>$latex T_{x_{0}}S$</span> אז אפשר לכתוב פשוט <span>$latex T_{x_{0}}S\subseteq\ker\left(\nabla f\left(x_{0}\right)\right)$</span> (אתם אמורים להכיר גרעין כי זה מושג בסיסי באלגברה לינארית; אוסף כל הנקודות שמאפסות את הטרנספורמציה הלינארית <span>$latex \nabla f\left(x_{0}\right)$</span>).</p>

<p>המשפט הזה מכליל את התוצאה שלנו על נקודות קיצון ללא אילוצים: אם אין אילוצים, אז המשטח <span>$latex S$</span> שלנו הוא המרחב כולו, ולכן הדרך היחידה שבה הוא יהיה מוכל בגרעין של טרנספורמציה לינארית כלשהי הוא שזו תהיה טרנספורמציית האפס (עם זאת, כמו שנראה בהמשך, אנחנו משתמשים במשפט ה”בסיסי” כדי להוכיח את המשפט הכללי יותר, כך שאי אפשר להשתמש במשפט הכללי כדי לחסוך לנו עבודה).</p>

<p>הדרך להגיע מהניסוח הזה לניסוח שהצגתי קודם היא דרך תוצאה לא מרתקת במיוחד באלגברה לינארית: נניח ש-<span>$latex f:\mathbb{R}^{n}\to\mathbb{R}$</span> היא טרנספורמציה לינארית ו-<span>$latex G:\mathbb{R}^{n}\to\mathbb{R}^{m}$</span> היא טרנספורמציה לינארית, אז <span>$latex \ker G\subseteq\ker f$</span> אם ורק אם קיימים <span>$latex \lambda_{1},\dots,\lambda_{m}$</span> כך ש-<span>$latex f=\sum\lambda_{i}G_{i}$</span>, כאשר <span>$latex G_{i}$</span> הוא ההטלה של <span>$latex G$</span> לרכיב ה-<span>$latex i$</span>, כלומר <span>$latex G_{i}\left(a\right)=\left[G\left(a\right)\right]_{i}$</span>.</p>

<p>מה שמעניין הוא להבין מה האינטואיציה שמאחורי המשפט הכללי. למה שהוא יהיה נכון? הנקודה הקריטית היא שאם <span>$latex S$</span> הוא משטח שמוגדר בצורה “נחמדה מספיק” אז בהינתן נקודה <span>$latex x_{0}\in S$</span> כלשהי, יש סביבה של <span>$latex x_{0}$</span> ש<strong>נראית כמו </strong>תת-מרחב לינארי של <span>$latex \mathbb{R}^{n}$</span>. ההגדרה של “יריעה”, שאני חומק ממנה בפוסט הזה, מפרמלת את הרעיון הזה; בואו נראה דוגמה פשוטה. את המעגל שלנו מתחילת הפוסט אפשר לתאר באמצעות <strong>פרמטריזציה</strong>: פונקציה גזירה <span>$latex p:\mathbb{R}\to\mathbb{R}^{2}$</span> שמוגדרת על ידי <span>$latex p\left(t\right)=\left(\sin t,\cos t\right)$</span>. על ה-<span>$latex p$</span> הזו אפשר <strong>להרכיב</strong> את <span>$latex f$</span> שלנו, שהיא הפונקציה שאנחנו מנסים לאפטמז, ולקבל את הפונקציה <span>$latex \varphi\left(t\right)=f\left(p\left(t\right)\right)=\sin t$</span>. קיבלנו פונקציה במשתנה בודד שמוגדרת מעל <span>$latex \mathbb{R}$</span>, כך שאפשר לחפש לה מקסימום ומינימום בדרך הרגילה - גוזרים ומשווים לאפס. תנסו, תראו שזה עובד.</p>

<p>אז גם באופן כללי, אם יש לנו פרמטריזציה של <span>$latex S$</span> בסביבה של <span>$latex x_{0}$</span> מצבנו טוב. בואו נניח ש-<span>$latex p:\mathbb{R}^{n}\to\mathbb{R}^{n}$</span> היא פרמטריזציה שכזו; פירוש הדבר הוא ש-<span>$latex p\left(\mathbb{R}^{n}\right)$</span> הוא סביבה של <span>$latex x_{0}$</span> ב-<span>$latex S$</span>. אנחנו מניחים שב-<span>$latex x_{0}$</span> יש ל-<span>$latex f$</span> נקודת קיצון מקומית; בואו נסמן ב-<span>$latex a\in\mathbb{R}^{n}$</span> נקודה שמקיימת <span>$latex p\left(a\right)=x_{0}$</span>. אז לפונקציה <span>$latex f\left(p\left(t\right)\right)$</span> יש נקודת קיצון מקומית ב-<span>$latex a$</span>, מה שאומר ש-<span>$latex D\left[f\left(p\left(a\right)\right)\right]$</span> תהיה טרנספורמציית האפס. מכלל השרשרת נובע שזה אומר ש-<span>$latex Df\left(p\left(a\right)\right)\cdot Dp\left(a\right)$</span> היא טרנספורמציית האפס.</p>

<p>עכשיו, את <span>$latex Df\left(p\left(a\right)\right)$</span> אנחנו מכירים בסימון קצת שונה. ראשית, <span>$latex p\left(a\right)=x_{0}$</span>. שנית, מכיוון ש-<span>$latex f$</span> היא פונקציה שמחזירה סקלר, אני מסמן את <span>$latex Df$</span> ב-<span>$latex \nabla f$</span>. כלומר, <span>$latex Df\left(p\left(a\right)\right)=\nabla f\left(x_{0}\right)$</span> הישן והטוב.</p>

<p>שנית, מה זה <span>$latex Dp\left(a\right)$</span>? זכרו ש-<span>$latex p$</span> היא פונקציה שמגדירה לנו משטח; לכן <span>$latex Dp\left(a\right)$</span> מתארת את המישור המשיק למשטח בנקודה <span>$latex p\left(a\right)=x_{0}$</span>, מה שסימנתי בתור <span>$latex T_{x_{0}}S$</span> (כן, זה היה נפנוף ידיים). כלומר, לכל קלט שהיא מקבלת, <span>$latex Dp\left(a\right)$</span> מחזירה לנו נקודה ששייכת ל-<span>$latex T_{x_{0}}S$</span>.</p>

<p>עכשיו, ראינו שההרכבה של <span>$latex \nabla f\left(x_{0}\right)$</span> על <span>$latex Dp\left(a\right)$</span> היא זהותית אפס. זה אומר שלכל קלט ש-<span>$latex Dp\left(a\right)$</span> מקבלת, הפלט שלה (נקודה ב-<span>$latex T_{x_{0}}S$</span>) יגרום ל-<span>$latex \nabla f\left(x_{0}\right)$</span> להחזיר אפס. מכיוון ש-<span>$latex Dp\left(a\right)$</span> היא פונקציה על כל <span>$latex T_{x_{0}}S$</span> נקבל את התוצאה - <span>$latex T_{x_{0}}S\subseteq\ker\nabla f\left(x_{0}\right)$</span>. הפורמליזם פה לא היה מלא אבל אני מקווה שהרעיון ברור עכשיו.</p>

  </div>

  <hr />
  <p>
    נהניתם? התעניינתם? אם תרצו, אתם מוזמנים לתת טיפ:
  </p>
  <a href='https://ko-fi.com/H2H5XFBQ' target='_blank'><img height='36' style='border:0px;height:36px;' src='https://az743702.vo.msecnd.net/cdn/kofi2.png?v=2' border='0' alt='Buy Me a Coffee at ko-fi.com' /></a><a class="u-url" href="/blog/2015/10/15/vector_calculus_critical_points" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">לא מדויק</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">לא מדויק</li><li><a class="u-email" href="mailto:gadial@gmail.com">gadial@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://www.facebook.com/%D7%9C%D7%90-%D7%9E%D7%93%D7%95%D7%99%D7%A7-163347110378474"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#facebook"></use></svg> <span class="username"></span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>בלוג על מתמטיקה ומדעי המחשב</p>
      </div>
    </div>

  </div>

</footer>

<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script>window.jQuery || document.write('<script src="/blogassets/js/jquery-slim.min.js"><\/script>')</script><script src="/blog/assets/js/bootstrap.bundle.js"></script></body>

</html>
